{
  
    
        "post0": {
            "title": "Vote counter and reporter",
            "content": "Introduction Yes, we’ve just seen it again in Iowa, but it’s not really a new thing or a new need: Use of electronic voting, counting and reporting is becoming the norm, and so are the problems and lack of trust in the process. . We need to do something. . Your job Your job is to design and implement an universal tool that can be trusted by everybody to help with voting, counting and reporting in any election. . Universal means that it be made to work (with configuration of course) for any kind of voting or election, be it for a party candidate for a major election to a simple class delegate at your university. . Trust will come from its open source nature which makes the code auditable. . Voting means that your system can be used by the voters to well, vote. This is probably the hardest part to get right as you need to somehow verify the voters identity. . Counting means that for those elections (which are probably all the political ones) in which the votes are counted after everybody has votes it must be possible for the people that are doing the counting to update their counts in real time and most importantly compare their counts in real time: The way it works, at least in some countries, is that after the electoral place closes, the ballot box is opened and the counting starts. That counting is done by several people (possibly selected randomly from the registered voters) but there are interested parties (such as party representatives) verifying that everything is done correctly. Those representatives of course are also keeping their own tallies, and at the end of the counting they must match the official count. . It goes in the interest of the process that everybody involved can see the official tally and everybody’s else. . Reporting means that after the counting is over the results can be reported to different places: Depending on who is doing the counting (meaning the user of you application) that reporting will go to their party, to the press, to an “upstream” counting place, or several or those at the same time. . Your system will have a mobile frontend that must be written in Flutter (which generates Android and iOS native aps). . It will also have a backend that can be written in anything, but it must be scalable. For example, a PHP backend is a non-starter. Think of using a massively scalable cloud service as the core of your backend. Remember that your application will have an extremely high usage during a short period of time and then it’s over. . Interesting read. . Finally, this system is not supposed to replace paper. We need the paper trail. It’s essential. . Qualification tasks Take a look at this page. . Your proposal should also include reports regarding scalability and fault tolerance of your chosen tech stack. A list of stacks and their performance comparison for the same application can be made from RealWorld.io .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-votecounter.html",
            "relUrl": "/2020/03/05/public-gsoc-votecounter.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Take-home qualification tasks",
            "content": "We know that working on existing codebases can be daunting, and you might end up working on a new project anyway, so this year we have some alternative qualification tasks (we’ll add more soon, so come back). . You can still opt for the standard ones (such as fixing issues on GitHub) — these are just alternatives that are available. . Interprocess communication (low-level) . Language: Modern C (not C++). Must work in: Linux . Create a program, in C, that utilizes queues and memory-based interprocess communication. . We’re writing a system that encodes video using hardware encoders, specifically nVidia GPUs. These consumer-grade GPUs are limited to two simultaneous encode sessions. However they can encode (really) fast, easily at 300 frames per seconds. . We want to overcome this limitation by distributing the load in software. Suppose you have 10 cameras each of them providing a never ending stream of video at 30 frames per second. The job is to come up with a good plan (and proof of concept) that maximizes GPU usage. . Here’s a few things that will help you: . You will need to have a queuing system that take the frames. Let’s assume on the assumption that there is one process that reads data from one specific camera, so if there’s 10 camera there are 10 such processes. They are the producers. Let’s call them CameraManagers. . | Because of the way video encoding works (in which one frame can be compressed a lot by using information from the previous one), you can ‘t just merge data from all the cameras and them send to the GPU as they arrive. Instead, you will need to batch them and send a number of frames from one specific camera (maybe 2 seconds, so 60 frames) at a time. We’ll call the program that manages the work queue and the GPU the GPU manager. . | Remember that while you do this the frames will continue to arrive. . | Frames are big, so you want to minimize copying data around. For this, you have shared memory between processes. . | A possibility here is to have one GPUManager, that will take the frames from the the CameraManagers. The GPUManager will need to keep one list of pending frames per camera and a queue of cameras. When a camera has sent 60 frames its list of pending frames is ready to be encoded. The GPUManager then encodes those frames (that causes a file to be generated with the output, but that’s not needed for this exercise) and clears the list. Remember that while encoding was in progress other frames may have arrived and you don’t want to lose them. . | As mentioned, there’s 2 encode sessions. The GPUManager needs to support that and simultaneously encode two frame-queues at a time. . | Cameras can be added, removed, and come down (for example, they can break, or their CameraMananger can crash). You system needs to be tolerant to this. . | You need to create the mockup CameraManager and the Mockup GPUManager. Since you don’t have cameras of course, for each frame read a block of 1280x800 bytes from /dev/urandom. . | Demostrate that it works will by validating the output, for example using a checksum of each input frame and writing it to the output which can be a sample text file that contains the “camera number”, “frame number”, and “checksum” for that frame, in order. . | . Meetup auto-RVSP . Language: Any Must work in: Linux . This task is relatively simple (in theory), but it will help us assess your code organization abilities. . Write a program for meetup.com that sends an auto-RVSP to specific groups. For example, suppose you are a member of 7 different Meetup groups, some of which have very popular events that fill up quickly. You want to sign up for them as fast as possible to ensure that you get a spot. . Your program needs take care of authentication, searching for events in configured groups (not all), and automatically signing up on the user’s behalf in a timely manner. Usage of existing Meetup client libraries is permitted. . It’s OK for your program to be a simple command-line tool that needs to be run from cron once an hour or something like that. . Plan for migrating our DokuWiki website to fastpages . Our website currently uses an easy-to-use wiki solution called DokuWiki, but the aesthetics could be better. . There’s a new platform that uses GitHub Pages for hosting and pull requests for content management. It seems to integrate well with things we care about, e.g. YouTube embeds. . Can you devise a good plan for migrating from DokuWiki to fastpages? . Export data from MyFitnessPal to Grafana . MyFitnessPal is a mobile app used to track food &amp; energy intake, exercise, and more. It supports CSV data export (e.g. through email) to facilitate archival, but this style is a bit antiquated for manual viewing. . A simple website that accepts CSV exports and renders nice visual representations using Grafana would be much better for users. This should be feasible to complete in a few days since all of the major components already exist. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-takehome.html",
            "relUrl": "/2020/03/05/public-gsoc-takehome.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "SwagLyrics-For-Spotify",
            "content": "You can find the project at GitHub. . You can find a list of important issues here. . Getting started / Requirements . The software is written in Python, so we expect good knowledge of Python. Basic HTML, Javascript &amp; CSS knowledge is also required. You should be able to demonstrate that you possess the skills to successfully implement your proposal. . We make use of quite some libraries to support all platforms, and we expect you to read up on the documentation of these platforms so you know how they work in general. . Qualification . If you are interested in taking up this project during GSoC, you will need to satisfy these requirements (in order of importance, not all are a necessity): . A well researched, well written project proposal. | Proof you’ve set up SwagLyrics locally and can set up an instance of the issue-maker for development. | Fixed a bug, improved existing features, solved issues, … (contributed something to the project). | Have chatted with the mentor(s) at least once. | . Mentor(s) . Aadi Bajpai (@aadibajpai on Slack) is a former GCI winner (2017) and mentor (2018, 2019). He wrote the software and is the official (and currently sole) maintainer. | .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-swaglyrics.html",
            "relUrl": "/2020/03/05/public-gsoc-swaglyrics.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Public:gsoc:sampleplatform",
            "content": "title = Google Summer of Code 2020 - The sample platform / Continuous integration revisited ~~ . The sample platform / Continuous integration . The sample platform was developed during GSoC ‘15 and overhauled during GSoC ‘16. In GSoC ‘17 another student added support for the Windows part, as well as some bugfixes. The student continued his work during GSoC ‘18, and will mentor this year. Last year a new student did some improvements and bugfixes. . This GCi edition we came to the conclusion that for new contributors, there are a bunch of drawbacks in the current system that make it no longer viable to continue to run the platform in it’s current form. . The two main issues are: . Long runtime if a lot of commits/PR’s are opened. This is because there is only one instance per OS available. | Unclear what the tests were being compared against. We should be able to have multiple approved versions and tell the user if the result deviates from those known ones. | . With a lot of different cloud offerings available and the launch of GitHub actions we want to iterate on the design of the Sample Platform, moving the infrastructure from a single dedicated server to a scalable service that can cope with the variations in load. . This will need an upfront survey of the existing functionality, followed by discussions with the mentor on how to implement this. . Features that will need to be implemented for certain are: . A coordinating platform that receives the call for actions, triggers the machines, displays results, … | Scalable Linux/Mac/Windows machines that can execute the regression tests (currently 180GB of samples!) | Deep integration with the GitHub Actions that should be run first (creating Linux, Windows, Mac builds), so that no time is wasted if there are compiler errors or no code changes. | Watch this video. Disregard that it’s about the Rust community - it’s the CD/CI part on it that is important to us. That’s what we want. | . Getting started / Requirements . The Sample Platform is written in Python, so we expect good knowledge of Python. The new project is not necessarily python-based, but the choice should be made based on maintainability (unit testing) and availability of third-party API’s and libraries. . Qualification . If you are interested in taking up this project during GSoC, you will need to satisfy these requirements (in order of importance, not all are a necessity): . A well researched, well written project proposal. This should include a monthly cost prediction based on expected runtime’s, disk storage used, … A comparison between multiple providers (e.g. Azure, GCP, AWS, Packet) must be included. | Have chatted with the mentor(s) at least once. | Fixed a bug, improved installation documentation, … (contributed something to the project). There are some issues in the tracker labeled issues labeled GSoC-proposal-task for this purpose. | Proof you’ve set up the Sample Platform locally. | . Additional information not necessarily well organized :-) . For each sample we currently have one “good” output. That’s not really correct. Changes in code might produce minor changes in the output (in the order of a few milliseconds). For each sample we’ll need to have a set of correct outputs (possibly with a “correctness score”). | When a pull-request is checked, our system now reports the number of “broken” samples, meaning how many samples are producing an incorrect output according to our “good output” list. This however does not help much determining how the output changes for this specific PR. Instead, the system needs to report the difference between the code before and after the changes in the PR, which is much more useful. | We’ll also need a way for final users to send test their own files against the current version so they don’t need us to release a new CCExtractor version that could fix something that is broken for them. | It should be possible for users to get a binary compiled by the new system, particularly for Windows (in linux we don’t have this problem since the typical way to install CCExtractor is just to build from source). Note that this build is already happening, so don’t worry much if you have zero interest on Windows :-) You can use what we already have in order to build. | We currently run all the tests for each PR. This is overkill. Instead, we should have different sets of tests, for example “only MP4 files”, or only “teletext”, and so on, and the developer should be able to decide which tests he needs to run his PR on (or maybe none, for example if he just edited the help screen). | One of the reasons we’re “going cloud” (as opposed to continue to run in one server) is the ability to scale and parallelize. It must be possible to check several PRs at the same time, different platforms, and so on. | We need to add a “regression finder” feature that works (and possibly uses) like git bisect: Give a specific sample find which specific commit changed the output. | . Mentor(s) . Willem Van Iseghem (@canihavesomecoffee on Slack) is a former GSoC student (2014, 2015, 2016) and mentor (2017, 2018, 2019). He started the project and is the official maintainer. | .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-sampleplatform.html",
            "relUrl": "/2020/03/05/public-gsoc-sampleplatform.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Roku reference channel",
            "content": "Roku is currently the most common media streamer. It’s cheap and neutral (it’s not in any “fight”). Unfortunately, there aren’t any good open source channels, so if you want to start your own you have to start from scratch. We want to fix that by creating the “reference” source code for a generic channel. We will send a free Roku to our student for development. . What makes a good Roku channel? . For the playback itself Roku provides a basic system in which you have the usual things such as play/store, fast-forward and so on. But there’s no default context menu, the progress bar is horrible and looks really bad… . Organization must be flexible and complete. Don’t assume that things belong in just one place. For example you may want to have a section of Python tutorials, one of AI videos, one of videos in Spanish and so on. Of course there’s videos that belong in all three places. . The home page must be well designed and pleasant to the eye. It must be easy to navigate. . Recommendations, last played, search, settings, etc, must be easy to find and by themselves need to be good. Note that the recommendation themselves belong in a backend and you don’t need to implement the actual backend: You need to implement the connection to such backend though. . You also need to support “activation”, which is the process in which the user links his Roku to an account existing in the system, for example to get access (case of a non-free channel) or custom recomendations. . Your job is the Roku channel itself, but you must provide a backend skeleton at the very least to support all the channel features. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-rokuchannel.html",
            "relUrl": "/2020/03/05/public-gsoc-rokuchannel.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Extend rclone’s webui",
            "content": "rclone webui currently supports basic plugins like a video player and a music player. This functionality could be extended to incorporate new plugins which could be added by a user on the go, and developers could develop these plugins for rclone. . The functionality will be something similar to Google Drive. Ex. If you want to edit a doc file, rclone webui will have a plugin for it, once you enable the plugin, you would be able to edit documents using rclone. . Deliverables: . A plugin dashboard, where you can install, remove and update plugins. | A plugins repository from where the plugins could be fetched into the local rclone instance. | The plugins should work in an isolated environment so that they cannot interfere with the system data. | Develop at least 3 demo plugins for demonstration. This could be a word processor, a photo editor, etc. | We could allow the developer to communicate with their own server and fetch data from there. | Current Stack: rclone backend: GoLang rclone webui: Reactjs . URLs: rclone GitHub: https://github.com/rclone/rclone react frontend: https://github.com/rclone/rclone-webui-react rclone forum: https://forum.rclone.org/ webui discussion thread: https://forum.rclone.org/t/beta-testing-webgui-for-rclone/11156 . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-rcloneweb2.html",
            "relUrl": "/2020/03/05/public-gsoc-rcloneweb2.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Program Flow Visualizer",
            "content": "Introduction . Read this and then come back here :-) . The Task . We want to build a complete profiler tool. During Google Code-in we created several proofs of concept, so we know it’s possible, and we also know that it’s a really good idea that got popular really fast. For reference, as you can see in the article linked above, five high school students created each their own implementation (by themselves) in around one month with really impressive results. . You can take their existing work (it’s open-source after all) and build upon it, or you can do your own thing. But of course, your product must demonstrate GSoC quality - you’ll be working full-time for 3 months :-) . Ideas . Explore use-cases other than algorithms (comment on Hacker News) . | Decorators to inform the debugger about the properties of user-defined data structures and classes . | Visualizations for more data structures: trees, linked lists, etc. . | Support for pausing, delays, and interactive messages, described via comments in the code . | Interactive web version (or just an output format) . | Flow control visualization, less of a focus on variables specifically (comment on Hacker News) . | Support for large target programs (multi-file projects) . | Integration with gdb and in general, support for other languages [if possible] . | Manual control keys (Play, pause, speed) . | Control flow chart (as an overview) . | Support for all types of objects in saved sessions, even those that cannot be serialized directly . | . This is another potential source of inspiration: https://github.com/hediet/vscode-debug-visualizer/tree/master/extension . Qualification tasks . In order to qualify for our projects, you must complete a qualification task or accrue sufficient qualification points from GitHub issues. . Take a look at this page for tasks oriented for people who are working on new projects like this one. Alternatively, you can go the traditional route of fixing GitHub issues on the main CCExtractor project, which is written in C. You can find more information about this here. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-pythonprofiler.html",
            "relUrl": "/2020/03/05/public-gsoc-pythonprofiler.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Public:gsoc:pythonbindings",
            "content": "Write Python bindings for CCExtractor . Extend Python to use CCExtractor’s library to access subtitles. You should export as much of CCExtractor as possible. At a minimum, it should be able to . Open and close input video streams. | For an open stream, get the list of programs. | For a selected program, get the subtitles in various easy to use structures. You need to provide access to the original representation (for example, if it’s US TV subtitles then a grid for CEA-608, if it’s European DVB subtitles then a bitmap) as well as the conversion to usual formats such as .srt. | . While CCExtractor itself uses its own library (lib_ccx), we are not aware of any other program using the library directly (as opposed to running CCExtractor and getting the generated file). This means - it’s likely you will also need to modify the library itself to make it “sane enough” for this project. . We will also be prefer to have Cython code written instead of simple Python wrappers during the program as they offer better speed and compatibility with our existing codebase. . **Related GitHub Issues** Make the Python Scripts to run Python3 Python Bindings don’t compile with build_library . **Related Github Commits** Make Python3 Compatible Code . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-pythonbindings.html",
            "relUrl": "/2020/03/05/public-gsoc-pythonbindings.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Poor Man’s Textract",
            "content": "Introduction Amazon Textract a (paid) service that “automatically extracts text and data from scanned documents. Amazon Textract goes beyond simple optical character recognition (OCR) to also identify the contents of fields in forms and information stored in tables.”. We want to build a free alternative that provides an output of similar quality. . Your job First, you’ll need to find lots of documents to process around the internet. We will provide you some, but you need to build your own corpus. A few ideas: . Tax documents. | Multiple-choice exams. | Immigration forms. | Resumes. | Contracts. | Blueprints. | Order forms. | Invoices. | . … and many more. . Then create a system that is able to identify the parts of all those models, write some output (for example, a JSON file) that contains the coordinates of each of the parts, writes each part to a separate file, and OCRs whatever information can be OCR’ed and writes it to a database (which can be as simple as document storage or a full-fledged SQL instance of your preferred flavor). . We strongly recommend you play a bit with Amazon’s Textract (for online tests it’s free) to get an idea of what to expect. . To get you started a bit you may take a look at what the GCI students did during last Christmas break (which only works for one specific use case, but it’s a reasonable proof of concept): . Musab Kılıç’s exam analyzer RobOHt’s exam analyzer knightron0’s exam analyzer . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-poormantextract.html",
            "relUrl": "/2020/03/05/public-gsoc-poormantextract.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Poor Man’s Rekognition (II)",
            "content": "Amazon Rekognition is a (paid) service that is able to identify objects, people, text, scenes, and activities in a picture. We want to produce a free alternative. . Last year we had a number of students working on this in parallel, which in itself was an experiment - we wanted to see if having several students in parallel try to do their own implementation would be better than just choosing the one we thought would best. . This year we are only going to select one. The first task is to get the best from last year (so you have to do some analysis of the existing implementations) and come up with ways to merge (or rewrite) and improve. Therefore the chosen student must do some homework in order to come up with a good proposal. Also check the current status of Rekognition. What new features would be great to have? Which features is Rekognition actually missing and we could add ourselves to make something better than Rekognition? . This is the description to last year’s project. . And here’s the links to all the projects (yes we know one of them is offline at this time): . https://medium.com/@amkr/final-work-submission-gsoc19-ccextractor-development-40a2b6c6a946 https://github.com/pymit/Rekognition . https://gitlab.com/drcpmkeyi/poor-man-rekognition . https://medium.com/@sziraqui/not-the-normal-gsoc-journey-d51a6167a3a6 . http://fedoskin.org/2019/08/24/gsoc-2019-poor-mans-rekognition/ . https://medium.com/@amkr/final-work-submission-gsoc19-ccextractor-development-40a2b6c6a946 . Qualification tasks . An important aspect of your proposal should be the report on which of the last year’s project is best or what part of each of them are best and should be reused in your projects. | Take a look at this page for more tasks. | .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-poormanrekognition2.html",
            "relUrl": "/2020/03/05/public-gsoc-poormanrekognition2.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Complete our OCR subsystem",
            "content": "Useful skills/interests: Image processing, Text Localization and Binarization, Tesseract API . Subtitles come in all shapes and colors. Some are text based (such as American closed-captions, as specified in CEA-608 and CEA-708, or the old European teletext). Others are bitmap based such as the European DVB. When subtitles use bitmaps they are a lot more flexible, but also a lot harder to transcribe. . For the Latin languages in DVB what we have works quite well. Note that while DVB is bitmap based, as least those bitmaps are separate from the main image, so you only need to OCR the bitmap to get the text. . However, there’s variants and cases that make things a lot more harder (and interesting): . Burned-in subtitles, in which they overlay the actual TV image. | Non-latin languages, such as Chinese. | Moving subtitles, such as the usual tickers on the screen that move from to side. | Subtitles with different colors, for example to distinguish between different speakers. | . Believe it or not some of these cases are also supported already in CCExtractor, at least for some “good” conditions. But the really hard ones, are still a job in progress. . The heavy lifting (the OCR itself) is done by tesseract. But selecting the area to process, prefilter it so tesseract gets an input it likes and so on, it’s done by our own code. . We need someone that likes challenges to make the whole thing work. . We will provide all the samples and access to a high speed server that has them so the student can work on it (optional) if a fast internet connection is not available to them. . **Related GitHub Issues** Extract cyrillic tickertape text in Russian from NTV Extract subtitles in a Chinese newscast GUI, Burned-in Subtitle Extraction not working jumps based on uninitialised values Process closed captions and burned-in subtitles in one pass DVB subtitles from China Corrupt or empty subtitles Terrible OCR results with Channel 5 (UK) . **Mentor** Abhinav Shukla (@abhinav95 on slack), which is the former Summer of Code student that worked on it last year and made an incredible job. . Qualification tasks Terrible OCR results with Channel 5 (UK) This task is ideal to get started, because you only need to deal with one function in one file: quantize_map() in src/lib_ccx/ocr.c . In addition to the samples that we already have, we would also like the creation of a dataset of a few hardsubbed (videos with burned-in subtitles) videos with the accurate timed transcripts so that we can evaluate the performance of our code on a wide variety of these real world samples. For the qualification task, this does not have to be huge. A good representative set will do fine. . Take a look at this page for more issues. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-ocr.html",
            "relUrl": "/2020/03/05/public-gsoc-ocr.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Mouseless for Linux",
            "content": "Introduction Mouseless is a nice tool to practice keyboard shortcuts for a few popular apps. Unfortunately it’s only available for Mac. We’d like to create an open-source Linux version that can be easily extended. . Your job We don’t want to clone Mouseless (we don’t have any relationship with their authors, and we don’t want to copy any of their work) - but the idea is good, and we think we can do a good job doing a tool that does a similar job of training users to use the mouse less and the keyboard more, but for the usual Linux tools. . We don’t know what’s the best technology is to build this, so we’re open to ideas. Just come up with a good plan, and a proof of concept for any Linux tool you like. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-mouseless.html",
            "relUrl": "/2020/03/05/public-gsoc-mouseless.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Add support for Live TV over the internet (such as YouTube TV)",
            "content": "A number of platforms are appearing these days to distribute local TV content over the internet. For example, YouTube now has a live TV. Hulu does, too. . It’s still early days for these platforms - they’re trying to grab the business from the cable-cutters, while (possibly, for now) providing the same functionality, which is a live TV with DVR. It’s possible of course that they will offer lots of new features and they manage to replace over the air broadcasts, cable… . Anyway, we don’t know how they are implementing subtitles, and the task this summer is to . a) Do the research b) Write code that is able to create transcripts in the usual formats such as .srt . This code might be integrated with the current CCExtractor core or it could be a new tool. What’s best depends mostly on how the subtitles are distributed. If they are embedded in transport streams then integrating with CCExtractor would be the natural option. It’s part of the job to figure this out. . We’re going to target the two major platforms that have a live TV over the internet: YouTube and Hulu. . We will pay for the subscriptions for both services during the coding period, and if you are currently outside the geographical areas in which these services are available, we’ll provide a VPN as well. . Features that we expect: . The system must be completely scriptable. For example, a solution that requires human intervention to start a capture session, or a browser open on a desktop is not going to work. Suppose we want the system running 24x7 on a Linux server, which might not even have a monitor. | Youtube TV supports a maximum of 6 simultaneous streams per subscription. We don’t know about Hulu, but the point is that your solution must be able to maximize what we get from the subscription - if the service allows 6 streams, your solution must too. | Allow several subscriptions to be used as well, for example, if we want 12 streams, then 6x2 should work. | It goes without saying, login information should be configurable and you must be careful not to push any real information to GitHub. | Documentation must be good - we want other projects to build on this one instead of having to figure out everything from scratch. | . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-livetvooverinternet.html",
            "relUrl": "/2020/03/05/public-gsoc-livetvooverinternet.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Public:gsoc:linuxtuning",
            "content": "Introduction The linux kernel has hundreds of tunable settings. Some can be modified on the fly with sysctl; others require reboots, loading modules and so on. . Your job Your job is to come up with a self-tuning system that does all the analysis it needs and finds the optimum settings to maximize throughput and/or latency for well defined workloads. One of the must be BitTorrent, since that one uses a lot of traffic and it can just be tested with real data instead of synthetic tests. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-linuxtuning.html",
            "relUrl": "/2020/03/05/public-gsoc-linuxtuning.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "JokerTV integration",
            "content": "As you may know, our reference TV tuner has been for a long time the amazing HDHomeRun from Silicon Dust. They (all models) are rock-solid and they are really easy to integrate with. However, they don’t support DTMB (the Chinese standard). . This small thing is JokerTV (stand-alone version). . You can see in the tech specs that everything we care about is supported, and that the list of chipsets is published, and that source code for everything, including firmware, is available. . We are quite excited about the openness and potential of JokerTV and want to be the first to integrate with it. What should be the result of this integration? . CCExtractor would be able to communicate directly with JokerTV - getting the streams directly from it, as we do with the HDHomeRun. | You don’t need to decode DTMB (that’s a different GSoC project, possibly a summer worth of work) but your integration needs to be as region agnostic as possible. If JokerTV works everywhere, then so must JokerTV+CCExtractor. | It’s likely that JokerTV included support tools are not up to par with HDHomeRun’s yet. If this is the case (your proposal should show that you’ve done your homework and can tell us) reserve some time to work on this. | Another two major programs that could use JokerTV integration are FFmpeg and Kodi (for their live TV and DVR functionality). We love cross project ideas, including of course sending patches to their maintainers. If you think you would have time for this, give it some consideration. | . About getting a JokerTV - we will buy one for the student that takes on this task. We will also have a few more distributed in different regions around the world so remote testing is possible. . **Related GitHub Issues** Extract subtitles in a Chinese newscast . **Mentor** Abylay Ospan, the genius behind JokerTV himself. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-jokertv.html",
            "relUrl": "/2020/03/05/public-gsoc-jokertv.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "Add Japanese support",
            "content": "Watch this video. . And then come with a plan :-) . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-japanese.html",
            "relUrl": "/2020/03/05/public-gsoc-japanese.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "rutorrent mobile interface",
            "content": "Introduction rutorrent is the most popular web interface for rtorrent, which is possibly the most used BitTorrent client in linux. It is mostly a web application, but it has its own backend that connects to rtorrent. You could connect to rtorrent directly as well, but by doing that you would be missing lots of features that come with rutorrent, for example RSS support. . Yes, there are two things with almost the same name. To summarize: . rtorrent =&gt; The BitTorrent client, a console-based tool that also has an API to interact with it. rutorrent =&gt; A web interface for rtorrent that uses that API. It also does other things, for example, it can download torrents from an RSS feed. You configure RSS feeds in rutorrent’s web interface, but there’s also a backend service (written in PHP) that is part of rutorrent to do the actual download. . Your job The job is to write a Flutter based web interface that uses rutorrent’s backend service to provide a native interface. . The basic things (for example, torrent listing) are easy to do, but rutorrent is extensible (it has good plugin support) and your tool needs to support that, too. . The job is to write a native application that feels written for mobile. It’s not about cloning rutorrent’s interface. So yes there needs to be a torrent list but the columns may be different (definitely less), colors, sorting, how you interact with the tool and so on. . rtorrent, by the way, runs in a server, and rutorrent is the web interface that lets you interact with rtorrent. We don’t want to add BitTorrent capability to mobile or anything like that. This is a 100% frontend job, using pre-existing work in rutorrent to control rtorrent from the phone. . Notes In order to understand what to do you need to actually install rtorrent and rutorrent and play with them. . You don’t need to have previous experience (really, not important for this - it’s all about Flutter), but you won’t be able to come up with a good proposal if you don’t know how things work. . Also, if you are unable to run rtorrent and rutorrent on your system, please use this docker image. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-flutterrutorrent.html",
            "relUrl": "/2020/03/05/public-gsoc-flutterrutorrent.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post17": {
            "title": "FFmpeg + Rust: Code builder",
            "content": "Why is this a CCExtractor project and not an FFmpeg project? Because the FFmpeg team doesn’t need it :-) We do. . Introduction FFmpeg is, of course, everybody’s go-to tool when it comes to video manipulation: Resize, apply filters, convert to a different encoding or container, etc, it does it all. They even participate in GSoC every year! . If you read their documentation, you will see that FFmpeg, the command-line tool, is mostly a “shell” that actually builds a graph that then runs in their libraries. . For developers that need to use FFmpeg to do “something” specific with video, the usual way to do it it just by executing FFmpeg with the right parameters (using spawn, exec, or whatever it’s called in their language of choice), wait for it to finish, and then do something with the result. . Often that’s good enough, but many times it’s not: You can’t easily get progress, you absolutely can’t do anything in the middle of the process and so on. . Your job Your job here is to build a “source code generator” that given a FFmpeg command line is able to write the source code of a program, preferably in Rust, that executes the graph using FFmpeg’s libraries - but this is not about spawning FFmpeg! For example, given a command line like this: . ffmpeg -i input.mkv -vf scale=320:240 output.mp4 . You can see that it’s going to read the file “input.mkv”, resize it to 320x240, and write it as output.mp4, so there’s a resize filter there and also a container conversion. . What we want to get is a program that does that for exactly those files and those tasks, and it needs to use FFmpeg’s low level libraries so it’s possible to add code into the program that does whatever the developer needs to do: For example, they might want to modify each frame to add something that is not supported by an FFmpeg filter - may be something that needs to be fetched for an external source. . Your output program needs to be compilable (of course) and do exactly the same thing as FFmpeg would do if called with the specified parameters. . Of course, you are expected to dig into how FFmpeg does it and build from there. . We prefer Rust but C would also be OK. However, if you already know C or C++ learning Rust is not too hard and it’s totally worth it. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-ffmpeg-rust.html",
            "relUrl": "/2020/03/05/public-gsoc-ffmpeg-rust.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post18": {
            "title": "Public:gsoc:dtmb",
            "content": "Add support for DTMB countries . DTMB is the Chinese TV standard, adopted by other countries such as Cuba. We still don’t know much about it. Due to this, your proposal must include: . a) A link to the relevant standard documents. We don’t know if they exist in English. If they don’t but you speak the language they are in, that’s fine. If you locate the documents but they require payment (as is often the case for technical specifications) send us a link to buy and we’ll allocate organization funds to purchase them. b) Some TV samples. Or, if you cannot get them directly, an explanation of how you will get them, for example by purchasing a capture card that is known to be compatible (send us an exact link), plugging it to an antenna or dish, etc, that you have access to (detail), etc. . In short, this is an “adventure” task. We’ll go all the way with the student that tries it, but we want to make sure the chances of success are reasonable. . This is what we (think we) know so far: DTMB regulates the physical transmission standard (signals, frequencies, etc). It seems to be available (for purchase) here. . Cuba follows it: http://www.globaltimes.cn/content/955479.shtml http://advanced-television.com/2013/03/22/cuba-adopts-chinese-tv-standard/ . The reason Cuba is interesting is that their subtitles will have Latin characters, which will make life a lot easier for most team members. Also, the Cuban government has a good website about their TV regulations. . Apparently the subtitles themselves follow the European DVB standard. We can see that in this document from the Hong Kong regulatory body which says: . Subtitles: Receivers shall include provisions to decode and display subtitles conforming to ETSI EN 300 743. . The Cuban government says the same thing: . That document (in English) says: The Brand and Model TV Set is intended for the reception of DTMB Digital Terrestrial Television in 6MHz bandwidth, according to the specifications GB 20600-2006. . and DVB subtitles (ETSI EN 300 743) – The DUT must support DVB subtitles (ETSI EN 300 743). . Important: Since Chinese is by far the most extended language among DTMB countries, its support is essential. We have some preliminary support for it, but whatever is missing you will need to add. This applies in particular to the .srt writer. Since .srt is text based, you need to OCR the bitmaps. This is already done but almost untested for Chinese. Don’t assume it’s going to work. Probably not. Give yourself time in your proposal for this. . **Related GitHub Issues** Extract subtitles in a Chinese newscast . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-dtmb.html",
            "relUrl": "/2020/03/05/public-gsoc-dtmb.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post19": {
            "title": "Public:gsoc:complete708support",
            "content": "Complete 708 support . 708 is the standard for digital TV in the US and a few other countries. We have preliminary support, but the goal is a 100% accurate implementation. This means: . a) Perfect timing. b) Perfect rendering, limited only by the output format. c) Full support to all languages for which samples are available. . We will provide hundreds of samples (for which you must complete support, no exceptions) and access to a high speed linux server for you to work with if needed. These samples are usually very large (hundreds of megabytes each) so working locally may not be feasible for you if you don’t have a great internet connection. . For developers in India we have someone there with an external 2 TB drive with a copy of all our samples. That drive goes from developer to developer, so if needed we can get it shipped to you. . If you are not in India or in a country in which just downloading the samples is the easy way, get in touch. We’ll figure something out so access to media is not a problem. . This is a high value task and we’d love to have it done, but in order to qualify you need to fix some of the existing bugs. . Also part of this idea: . https://github.com/CCExtractor/ccextractor/issues/733 . Which is about implementing .mcc support, which as the GitHub ticket says complements 708 very well. . Getting started: . The wikipedia page on 708 This is quite good actually. It’s not a complete description of the standard, but it’s quite useful to understand what 708 is about. . **Related GitHub Issues** Ver 0.85 CEA-708: 16 bit charset (Korean) Not support (problem extract Korean subtitles [CEA-708] Missing the last subtitle [CEA-708] [Timing] Catchable bug with timing Finish CEA-708 support . **Mentors** Carlos Fernandez Sanz (@carlos.fernandez on slack). Carlos wrote the original CEA-708 code. Evgeny Shulgin (@izaron on slack). Evgeny is a 2016 Code-In Winner with CCExtractor, and worked a lot on CEA-708. . **How to get started** Best thing you can do is download a few samples (check our TV samples page) and try to solve some of the CEA-708 issues we have listed on GitHub. . This is also the best way to get accepted into GSoC. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-complete708support.html",
            "relUrl": "/2020/03/05/public-gsoc-complete708support.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post20": {
            "title": "The next peer-to-peer protocol",
            "content": "Introduction BitTorrent is, of course, the world’s most used peer to peer protocol. It’s great, but it was designed before the cloud was ubiquitous and it doesn’t make use of the places where you have the most storage or the most bandwidth. Can we design something for the next decade? . BitTorrent is based on the concept of peers, which are BitTorrent clients, usually running on computers at home, that share data is a super-efficient manner. It works well, of course, but . It requires users to have their computers on for a long time | It requires users to expose their IP address | It requires users to use their home internet connection, making it hard to do other things at the same time such as streaming | . There are of course alternatives (you can rent servers in data centers for example), but they are not cheap, they’re not easy to set up, and they come with their own sets of problems, in general. . These days most people have lots of their data in the cloud: Dropbox, Google Drive and so on. . Your job The goal here is to come up (and implement the first version) with a system that let those personal storage systems exchange data . Securely | As cheap as possible | As fast as possible | As easily as possible | . A possible idea (one of many possibilities) would be to introduce the concept for “agent”. An agent would be a process that runs in the cloud on behalf of the user and that has access to his personal storage accounts. The agents can run anywhere, but their ideal place is the cloud, for example, AWS or Google Cloud. They can be managed by the final user or by a 3rd party that provides the service. . Agents find each other, and learn to trust each other, with the help of repositories, the equivalent of today’s trackers. . Agents that trust each other can vouch for other agents. . The chain of trust must always be preserved so agents can prune trees if the trust is broken. . Qualification tasks Take a look at this page. .",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-cloudtorrent.html",
            "relUrl": "/2020/03/05/public-gsoc-cloudtorrent.html",
            "date": " • Mar 5, 2020"
        }
        
    
  
    
        ,"post21": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . Front Matter is a markdown cell at the beginning of your notebook that allows you to inject metadata into your notebook. For example: . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks just like you can with markdown. . For example, here is a footnote 1. . . This is the footnote.&#8617; . |",
            "url": "https://dumbmachine.github.io/ccextractor-wiki-test/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://dumbmachine.github.io/ccextractor-wiki-test/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  
  

  

  
  

  

  
      ,"page8": {
          "title": "Google Summer of Code 2020",
          "content": "Welcome to our ideas page. It’s great you want to start early. Please join us in our slack channel! (we’ll leave as an exercise to you to find it — it’s on our website). . This is going to be an amazing year — lots of new things to work on, including JokerTV, a totally open TV receiver, plus several experimental/for fun projects. Projects in C, Node.js, Python, Rust and more, you name it, we have it. Plus resources for students — we’ll give access to a high-speed server, all our samples (we’ll even ship a portable drive with them anywhere in the world, so don’t worry about slow connections) and various other perks. . You are welcome to check out the page (actual ideas at the bottom of the page, with each project having it’s own separate page as well) and start early in the community bonding process as well as learning a bit about our code ethics and practices. And of course, we’d love you to stay around even if we are not invited to GSoC or if we cannot invite you as a student. . The ideas we currently have . Important: If you have something else in mind that relates to subtitles and accessibility please get in touch. We prefer that you do something that you are passionate about even if it’s something we hadn’t considered. . After you check out our ideas please continue reading to the bottom of the page to get information about who we are, how we collaborate, what resources we will provide to you, etc. . Some tasks descriptions are still vague. We know that. Feel free to get in touch for questions, or just check their page from time to time. We will update the descriptions often. . Core subtitle tool (CCExtractor itself) . Name Description Tech you need to know Tech you will learn Difficulty . Complete 708 support | This is one of the big ones. Why? Because it’s been on our wish list for some time and until now no one has decided to really go for it; after the initial work it’s always been incremental improvements, but no one has raised their hand and said “I’m going to complete this”. It’s possible the code base is not really friendly. Who knows. If this is the case we’re OK with a total rewrite if that’s what it takes to get this done. The details page has some more information if this picked your interest. This project is guaranteed to be selected if the proposal is good. | C | Video standards Subtitle standards CCExtractor internals Internationalization | Hard | . Add support for streaming Live TV | A number of streaming platforms now offer support for internet based live TV, which is great: It lets you watch TV on the go, it lets you get rid of cable, satellite and areal antennas… unfortunately, this live TV is not standardized at all. Your job is to do the work to add suport for Hulu and Youtube. We will pay for the subscription costs as well as any required infrastructure. | Any | Video standards Subtitle standards Live streaming platforms | Unknown | . Work on JokerTV integration | JokerTV is an excellent open hardware and software platform (think Arduino, but for TV). It’s still early days, and we really want to be among the first supporting this amazing new platform. JokerTV can receive signals from all TV standards around the world (finally!, no more European or American models, etc). We will buy one device for the student (or students, if their ideas are different) that works on this. Abylay Ospan, the genius behind JokerTV has agreed to mentor. | C | Hardware Video standards Joker (the platform) | Unknown | . Write Python bindings for CCExtractor | This was partially done during GSoC 2017, but the approach was totally wrong — a wrapper, instead of Cython. Let’s cut our losses and start over. | C Python | Obscure C+Python topics CCExtractor internals | Medium | . Add support for DTMB countries | DTMB is the standard for Chinese TV, also implemented by countries such as Cuba. What kind of student is ideal for this task? One with lots of analytic skills and patience. If you are one of those, don’t disregard this task just because you don’t speak (or maybe, even care) about Chinese. The experience on dealing with this will be extremely valuable in the future. We will use part of the organization funds to buy standard documents you might need, a capture device, and in general, anything required to make your life easier. | C | DTMB Video standards Hardware Research | Unknown | . Improve our OCR subsystem | We use tesseract to OCR bitmap based subtitles. In theory this is straight forward, but when you take into consideration all variants (color, languages, subtitles burned-in image, even moving text such as tickers) the complexity grows fast. Still, the work done by PhD students in the past is great, and we’re confident this year we can complete the work on this area if someone of the same caliber decides to join the effort. | C | Tesseract Imaging OCR | Suspected hard | . Add Japanese support | Captions are used by people all over the world on a regular basis. Most of us are familiar with regular horizontal captions at the bottom of the screen, but did you know that in Japan a common position for captions is vertically on the right or left side of the screen? Come learn more about what Japanese audiences need out of captions as well as how captioning standard likes IMSC and WebVTT support these features. | Japanese (or be good with foreign languages) | Depends | Suspected hard | . Artificial Intelligence and clever algorithms . Name Description Tech you need to know Tech you will learn Difficulty . Poor man’s Rekognition (II) | Amazon Rekognition is a (paid) service that is able to identify celebrity faces in a picture. Last year we did some work towards creating a free alternative. This year we want to improve on the past work. | Your choice | AI Computer vision | Unknown | . Poor man’s Textract | Amazon Textract a (paid) service that “automatically extracts text and data from scanned documents. Amazon Textract goes beyond simple optical character recognition (OCR) to also identify the contents of fields in forms and information stored in tables.”. We want to build a free alternative that provides an output of similar quality. | Your choice | AI Computer vision OCR | Unknown | . Support tools we and other orgs use as part of their development process . Name Description Tech you need to know Tech you will learn Difficulty . The sample platform (/ continuous integration) project | The sample platform is a good way to help new contributors to check if their code doesn’t introduce any regressions. It’s pretty stable, but is often hard to interpret for new contributors, and still pretty slow if the queue builds up. We want to take the concepts of this existing platform and re-write it from scratch making use of the horizontally scalable cloud options that are nowadays available. This project is guaranteed to be selected if the proposal is good. | Git Python | Cloud services API’s GitHub Actions GitHub API’s Continuous Integration (CI) Automated deployments GitHub integration | Medium/Hard | . New things we’re currently interested on . Name Description Tech you need to know Tech you will learn Difficulty . A reference channel for Roku | Roku is currently the most common media streamer. It’s cheap and neutral (it’s not in any “fight”). Unfortunately, there aren’t any good open source channels, so if you want to start your own you have to start from scratch. We want to fix that by creating the “reference” source code for a generic channel. We will send a free Roku to our student for development. | None | Brightscript Roku Video Streaming | Medium | . An “algorithm video creator” in Python | During Google Code-in we got some proof of concepts that are actually quite cool. We want to build a complete tool that helps study and understand algorithms | Python | Python internals Algorithms | Medium | . FFmpeg + Rust | This project is two fold: One, is create proper Rust bindings into FFmpeg’s libraries. The 2nd, and harder, is create a “graph to code” generator | C or C++ | FFmpeg’s internals Rust | Possibly hard | . Extend rclone’s web UI (mentored by Nick Craig-Wood, rclone’s developer) | rclone is a fantastic tool to synchronize cloud storage. It’s rsync for the cloud. Last year we started a web UI, and it was a successful GSoC project. We want to continue working on it. | Cloud (lots) Web (different tech) | — | Medium | . SwagLyrics | Last Summer of Code, we came up with a platform to align lyrics to their temporal location in the audio (https://github.com/SwagLyrics/autosynch). This year, we want to improve it, and integrate it to SwagLyrics proper. | Python (mainly) | Depends on your idea | Medium to Unknown | . Vote counter and reporter | More and more countries depend on electronic vote counting and/or reporting in their elections, and apparently no one can get this right. Either no one knows how to do it or they know exactly what they are doing. Both things are worrying, to say the least. We want to spend this summer working on an open-source solution everybody and use and audit, in any country. | Systems design | Flutter (frontend), your choice (backend) | Hard | . Mouseless for Linux | Mouseless is a nice tool to practice keyboard shortcuts for a few popular apps. Unfortunately it’s only available for Mac. We’d like to create an open-source Linux version that can be easily extended. | Your choice | ?? | Unknown | . rutorrent mobile interface | rutorrent is the most popular web interface for rtorrent, which is possibly the most used BitTorrent client in linux. The job is to write a Flutter based web interface that uses rutorrent’s backend service to provide a native interface. | Flutter | BitTorrent | Medium | . The next peer-to-peer protocol | BitTorrent is of course the world’s most used peer to peer protocol. It’s great, but it was designed before the cloud was ubiquitous and it doesn’t make use of the places where you have the most storage or the most bandwidth. Can we design something for the next decade? | Depends | Peer-to-peer, cloud | Medium | . Linux tuning for network throughput | Come up with a system that tunes the linux kernel to maximize network throughput for a number of workloads, such as web server or BitTorrent | Linux | Kernel internals, Networking | Hard | . About us . We are a small org, which means that your contribution will have a large impact. It’s not going to mean a 0.5% improvement on a big project — it’s going to be more than 10% on a medium size one. If you like challenges and want a chance to shine this is your place. . We have -we think- statistically amazing continuity in the team: Most GSoC students from all the past years are still involved, even if they are no longer eligible as students. They still contribute code, and they mentor both in GSoC and the sister program GCI. As mentors, they also come to the Summer of Code summit which traditionally takes place in October. . We have mentors all over the world (North America, Europe, Asia and Australia), so time zones are never a problem. Our main channel of communication is a Slack channel to which everyone is welcome. We expect all accepted students to be available on Slack very often, even if you don’t need to talk to your mentor. This will help you ask questions when necessary, and you might be able to help others out as well while working on your project. . Exception: If your country (such asRussia) has banned Slack please get in touch in we’ll work out a solution with you. We absolutely want you to participate. . A mailing list is also available for those that prefer email over slack. It’s a new mailing list (the old one hasn’t been used in a long time) but it’s read by everyone involved in GSoC. . All our top committers will be mentoring. Many of them are former GSoC students or winners of GCI. . Perks . All accepted students get a programming book immediately after being accepted, with the hope that they read them before the coding starts. We want to see if this increases the quality of the work. So far we have selected these three books (pick one), but we’re open to suggestions: Clean Code, Elements of Programming Interviews in Python, Cracking the code interview. . We will also provide to all accepted students: . 6 months of access (from the acceptance date) to all courses in educative.io | 12 months of access (from the acceptance date) to backtobackswe, which is a fantastic resource to learn algorithms, prepare for coding interviews, and in general learn fundamentals. | . The student working on CEA-708 will also receive a copy of the latest CEA-708 specification document. . About what we use . This is what we usetoday. It doesn’t mean this is what we want to continue using. Probably not — we’re really open to change. We’re just describing the status quo so you know what you are getting into :-) . The core tool that names the organization (CCExtractor) is a command-line program written inC(not C++). . The current Windows GUI is written inC#, and we have another GUI for Linux that’s written with Qt, and a small GUI that’s integrated into the main program (C). In we’re being honest, nothing is great. Good news for you is that you can start over if you want. . The testing tool we use to run regression tests is mainly written inPython, but it also used Javascript, CSS and some shell scripting. The Test suite is written in C#. One of the projects this year is about replacing it. . The prototype real time subtitle website is written inNodeJS. . We also have a number of support tools that do a number of different things, from downloading subtitles from streaming services to translating them with Google Translate or DeepL. Most of them are written inPython, but since they are small tools that do their job you don’t need to worry much about them. . For totally new things you can use whatever tool you feel is best for the job. . About sample media and other resources . We work with huge files. Not all of them are huge, but many are. We know that many students don’t have access to high speed internet. To those students we will ship (as soon as they are selected) a portable hard drive with all our samples. So if your internet connection is not good, don’t worry — as long as you can plug a USB drive to your development computer you can participate with us. . We also have a shared Linux development server with lots of storage and a Gigabit uplink. Students get an account on it and they are welcome to use it. There’s nothing there except our own work, so it’s a trusted environment (for a server that is connected to internet of course). . The sample platform also hosts a bunch of samples, both which are small or decently sized. . Some projects have specific requirements: For example to add support for JokerTV you will need a physical JokerTV device. We will send one to the student that takes this project well before GSoC starts. The LiveTV project requires a subscription to YouTube with LiveTV (whatever it’s called this week) and Hulu. We will pay for those. If your project requires some cloud resources (Google Compute Engine, for example), we will pay for that, too. . In general, you are not expected to pay for anything (other than your own development computer and internet, of course) related to any project. . If you need anything not mentioned (such as a book) let us know. Within reason, we’ll help you. . About the projects and getting accepted . Qualification: Our selection system is based on several factors. Of course no student ranks in all criteria, so don’t worry when you read the list below. . Work on our core tool: Even if you are going to be working on something totally different. This might seen counter intuitive, but the thing is if you prove you can dig into our (messy) code base, find yourself your way around it, and fix a few bugs, you are just the kind of person we can trust to “figure things out”. GSoC is among other things, a learning experience. No matter what project you decide to work on, there’s going to be roadblocks, things you don’t know how to do, etc. So we really like it when students embrace those situations. . Qualification tasks specific to the project: The detail page for some projects contains specific qualification tasks that apply to them. . Contributions to existing open source projects: This can be anything. From a good GitHub profile to pull-requests sent to any other existing project, participation in hackathons, Google Code-In, past GSoCs and so on. . A good proposal: This is the one criteria that is non-negotiable. Your proposal has to be good, period. . Project popularity: Some ideas just have more competition, so if participating in GSoC is a top priority for you (over working on a specific project), consider applying to one of the “niche” ideas. After all, that’s a great way to get your foot in the door :-) . Best core tool tasks . We’re added a difficulty level to all our open issues on GitHub. Best thing you can do is head there and see if you are able to fix some of the easy ones and work your way up. We don’t expect you to be able to do the hard ones but we’d be impressed if you did :-) . For some of the easy ones you don’t even need to know C. Just being able to compile CCExtractor and dig around a bit will be enough. . The sample platform’s issues are tagged with “gsoc-proposal-task”, so you can easily see what you can work on. . Take home qualification tasks . If instead of working on existing code you’d prefer to show us your skills working on something new, you can pick one of these projects. . Community etiquette . It goes without saying that everyone in the community has to be polite and respectful, and consider everyone else a member of a team and not a competitor. . All developers are part of the team, by the way. Our Slack channel has mentors, code-in participants, other students, or developers and users that are none of the above but they all play some kind of role in CCExtractor’s community. . Part of being respectful is giving consideration to everyone else’s time. Most of us have day jobs, and as such are limited in the time we can use to guide you. We’d like to spend it on quality discussions, and not on things that are for example written on this website, things that you can easily retrieve by reading documentation on used libraries or on the software’s help screen. Asking this kind of questions in the Slack channel shows little respect for our time. This doesn’t mean you can’t ask questions, but remember that being a clueless user and a lazy developer are two very different things. If you ask those questions you will probably get an answer as if you were a clueless user (polite no matter what), but if you apply to GSoC you will be considered a lazy developer. Google is your friend ;) . Tell things as you see them. Politely -you’re not Linus-, but don’t sugar-coat it. We know some parts of our code is poorly written, poorly documented, etc. It stands out, so you will know when you dig in. No one is going to be offended by having that code rewritten or refactored. Peer review applies to everybody’s work and is done by everybody. . Cross project proposals . Because we use a number of libraries and in fact “are a library” ourselves (meaning other programs can link CCExtractor as a library, or invoke the binary) we interact with other communities and their software. From time to time there’s a chance to do something interesting that affects CCExtractor and something else (FFmpeg comes to mind, but also Kodi, VLC, libGPAC, Red Hen, to mention just a few of our friends that typically participate in Summer of Code). So how does this work? As long as the work benefits CCExtractor and it’s part of your summer project, we’re OK with you spending some time on the other project. For example if you are improving our MP4 support, for which we use libGPAC, and need to fix or improve something on libGPAC you are welcome to do so. If you do, make sure you submit your changes to their maintainers and follow through with their merge process. . Your proposal . You can propose to do any of the following ideas, or you can bring your own. In any case, make sure you run them by us before you actually submit your proposal. . At the very least your proposal needs to . Explain what you do want to do, why it is important to you (don’t make up a story here — the reason can be that you need it, that you just think it’s cool, that you have an itch to work on it, etc), and why it could be important or useful to us. | Explain how you intend to accomplish the goal, in enough detail that makes it clear that you have done your homework. For example, “I will modify the CCExtractor binary so that it’s able to convert audio to text with perfect accuracy” is the same thing as sending your proposal to the trash. You need to have a plan. | Detail the timeline explaining what the expected progress is for each week or every two weeks (pay special attention to the milestones within the GSoC timeline itself, of course) and how we should validate the results. | Detail what kind of support you will need from us. For example, if you are going to need test streams, hardware, access to a server, etc, let us know, so we can prepare everything for you as soon as possible. | Detail your expected working hours in UTC. We’re used to weird working schedules, so don’t worry about working in the middle of the night, or weekends instead of other days, etc. Knowing your hours may help us to match you better with a mentor. | Mention your planned absences. We don’t need you to detail what you will be doing when you are not working of course, but if you are going away for any reason we need to know so we don’t think you’ve abandoned. | Link to your GitHub (or any other repository) profile, if you have one, so we can take a look at your previous work. | GSoC is a coding program: This means that ideas that are about testing (unless it involves coding something to test our programs ;) ), website design, etc, are out. | However, we want to have good documentation: Make sure you have time to write a good technical article explaining your work. | Be realistic and honest with the timeline. Consider each week you should work around 30 hours. If your timeline reserves a lot of time for minor things we’ll think that you are not going to be working full-time in GSoC. On the other hand if you promise to do things in a lot less than that it seems realistic to us it will seem that you don’t really know how much work things take. | If you are going to be using 3rd party libraries (that’s OK), make sure to validate that their license is compatible with GPLv2 (which is ours). List the libraries in your proposal. Check that they are cross-platform. If you will need to extend those libraries in any way please explain. In this case, your proposal should include time to get that extension submitted to the maintainers (we love to contribute to other projects). | . Something else: Mentors often have their fingers in several pies. If you send the same proposal to several orgs everyone will know. So do yourself a favor and don’t do that. You can apply to several organizations and that’s totally fine, but each organization will want to see that you have put the time to write a great proposal that is focused on them. . Useful resources . A great resource for GSoC. .",
          "url": "https://dumbmachine.github.io/ccextractor-wiki-test/_pages/Gsoc%20start%20here.html",
          "relUrl": "/_pages/Gsoc%20start%20here.html",
          "date": ""
      }
      
  

  
      ,"page9": {
          "title": "",
          "content": "Warning . Do not manually save images into this folder. This is used by GitHub Actions to automatically copy images. Any images you save into this folder could be deleted at build time. .",
          "url": "https://dumbmachine.github.io/ccextractor-wiki-test/images/copied_from_nb/",
          "relUrl": "/images/copied_from_nb/",
          "date": ""
      }
      
  

  
  

}