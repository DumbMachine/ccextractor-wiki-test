<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://dumbmachine.github.io/ccextractor-wiki-test/feed.xml" rel="self" type="application/atom+xml" /><link href="https://dumbmachine.github.io/ccextractor-wiki-test/" rel="alternate" type="text/html" /><updated>2020-03-05T13:46:17-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/feed.xml</id><title type="html">CCExtractor</title><subtitle>Test to try and use fastpages to host GSOC 2020 related data of dokuwiki based CCExtractor blog on fastpages</subtitle><entry><title type="html">Vote counter and reporter</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-votecounter.html" rel="alternate" type="text/html" title="Vote counter and reporter" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:votecounter</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-votecounter.html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;br /&gt;
Yes, we’ve just seen it again in Iowa, but it’s not really a new thing or a new need: Use of electronic voting, counting and reporting is becoming the norm, and so are the problems and lack of trust in the process.&lt;/p&gt;

&lt;p&gt;We need to do something.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your job&lt;/strong&gt;&lt;br /&gt;
Your job is to design and implement an universal tool that can be trusted by everybody to help with voting, counting and reporting in any election.&lt;/p&gt;

&lt;p&gt;Universal means that it be made to work (with configuration of course) for any kind of voting or election, be it for a party candidate for a major election to a simple class delegate at your university.&lt;/p&gt;

&lt;p&gt;Trust will come from its open source nature which makes the code auditable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Voting&lt;/strong&gt; means that your system can be used by the voters to well, vote. This is probably the hardest part to get right as you need to somehow verify the voters identity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Counting&lt;/strong&gt; means that for those elections (which are probably all the political ones) in which the votes are counted after everybody has votes it must be possible for the people that are doing the counting to update their counts in real time and most importantly compare their counts in real time: The way it works, at least in some countries, is that after the electoral place closes, the ballot box is opened and the counting starts. That counting is done by several people (possibly selected randomly from the registered voters) but there are interested parties (such as party representatives) verifying that everything is done correctly. Those representatives of course are also keeping their own tallies, and at the end of the counting they must match the official count.&lt;/p&gt;

&lt;p&gt;It goes in the interest of the process that everybody involved can see the official tally and everybody’s else.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reporting&lt;/strong&gt; means that after the counting is over the results can be reported to different places: Depending on who is doing the counting (meaning the user of you application) that reporting will go to their party, to the press, to an “upstream” counting place, or several or those at the same time.&lt;/p&gt;

&lt;p&gt;Your system will have a mobile frontend that must be written in Flutter (which generates Android and iOS native aps).&lt;/p&gt;

&lt;p&gt;It will also have a backend that can be written in anything, but it must be scalable. For example, a PHP backend is a non-starter. Think of using a massively scalable cloud service as the core of your backend. Remember that your application will have an extremely high usage during a short period of time and then it’s over.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.theatlantic.com/technology/archive/2020/02/bad-app-not-russians-plunged-iowa-into-chaos/606052/&quot;&gt;Interesting read&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, this system is not supposed to replace paper. We need the paper trail. It’s essential.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Your proposal should also include reports regarding scalability and fault tolerance of your chosen tech stack. A list of stacks and their performance comparison for the same application can be made from &lt;a href=&quot;https://github.com/gothinkster/realworld&quot;&gt;RealWorld.io&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction Yes, we’ve just seen it again in Iowa, but it’s not really a new thing or a new need: Use of electronic voting, counting and reporting is becoming the norm, and so are the problems and lack of trust in the process.</summary></entry><entry><title type="html">The next peer-to-peer protocol</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-cloudtorrent.html" rel="alternate" type="text/html" title="The next peer-to-peer protocol" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:cloudtorrent</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-cloudtorrent.html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;\&lt;br /&gt;
BitTorrent is, of course, the world’s most used peer to peer protocol. It’s great, but it was designed before the cloud was ubiquitous and it doesn’t make use of the places where you have the most storage or the most bandwidth. Can we design something for the next decade?&lt;/p&gt;

&lt;p&gt;BitTorrent is based on the concept of peers, which are BitTorrent clients, usually running on computers at home, that share data is a super-efficient manner. It works well, of course, but&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It requires users to have their computers on for a long time\&lt;/li&gt;
  &lt;li&gt;It requires users to expose their IP address\&lt;/li&gt;
  &lt;li&gt;It requires users to use their home internet connection, making it hard to do other things at the same time such as streaming\&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are of course alternatives (you can rent servers in data centers for example), but they are not cheap, they’re not easy to set up, and they come with their own sets of problems, in general.&lt;/p&gt;

&lt;p&gt;These days most people have lots of their data in the cloud: Dropbox, Google Drive and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your job&lt;/strong&gt;&lt;br /&gt;
The goal here is to come up (and implement the first version) with a system that let those personal storage systems exchange data&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Securely\&lt;/li&gt;
  &lt;li&gt;As cheap as possible\&lt;/li&gt;
  &lt;li&gt;As fast as possible\&lt;/li&gt;
  &lt;li&gt;As easily as possible\&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A possible idea (one of many possibilities) would be to introduce the concept for “agent”. An agent would be a process that runs in the cloud on behalf of the user and that has access to his personal storage accounts. The agents can run anywhere, but their ideal place is the cloud, for example, AWS or Google Cloud. They can be managed by the final user or by a 3rd party that provides the service.&lt;/p&gt;

&lt;p&gt;Agents find each other, and learn to trust each other, with the help of repositories, the equivalent of today’s trackers.&lt;/p&gt;

&lt;p&gt;Agents that trust each other can vouch for other agents.&lt;/p&gt;

&lt;p&gt;The chain of trust must always be preserved so agents can prune trees if the trust is broken.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction\ BitTorrent is, of course, the world’s most used peer to peer protocol. It’s great, but it was designed before the cloud was ubiquitous and it doesn’t make use of the places where you have the most storage or the most bandwidth. Can we design something for the next decade?</summary></entry><entry><title type="html">Public:gsoc:complete708support</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-complete708support.html" rel="alternate" type="text/html" title="Public:gsoc:complete708support" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:complete708support</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-complete708support.html">&lt;p&gt;&lt;strong&gt;Complete 708 support&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;708 is the standard for digital TV in the US and a few other countries. We have preliminary support, but the goal is a 100% accurate implementation. This means:&lt;/p&gt;

&lt;p&gt;a) Perfect timing.&lt;br /&gt;
b) Perfect rendering, limited only by the output format.&lt;br /&gt;
c) Full support to all languages for which samples are available.\&lt;/p&gt;

&lt;p&gt;We will provide hundreds of samples (for which you must complete support, no exceptions) and access to a high speed linux server for you to work with if needed. These samples are usually very large (hundreds of megabytes each) so working locally may not be feasible for you if you don’t have a great internet connection.&lt;/p&gt;

&lt;p&gt;For developers in India we have someone there with an external 2 TB drive with a copy of all our samples. That drive goes from developer to developer, so if needed we can get it shipped to you.&lt;/p&gt;

&lt;p&gt;If you are not in India or in a country in which just downloading the samples is the easy way, get in touch. We’ll figure something out so access to media is not a problem.&lt;/p&gt;

&lt;p&gt;This is a high value task and we’d love to have it done, but in order to qualify you need to fix some of the existing bugs.&lt;/p&gt;

&lt;p&gt;Also part of this idea:\&lt;/p&gt;

&lt;p&gt;https://github.com/CCExtractor/ccextractor/issues/733&lt;/p&gt;

&lt;p&gt;Which is about implementing .mcc support, which as the GitHub ticket says complements 708 very well.&lt;/p&gt;

&lt;p&gt;Getting started:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CEA-708&quot;&gt;The wikipedia page on 708&lt;/a&gt; This is quite good actually. It’s not a complete description of the standard, but it’s quite useful to understand what 708 is about.\&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**Related GitHub Issues**&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/690&quot;&gt;Ver 0.85 CEA-708: 16 bit charset (Korean) Not support&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/677&quot;&gt;(problem extract Korean subtitles&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/646&quot;&gt;[CEA-708] Missing the last subtitle&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/641&quot;&gt;[CEA-708] [Timing] Catchable bug with timing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/3&quot;&gt;Finish CEA-708 support&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**Mentors**&lt;/strong&gt;&lt;br /&gt;
Carlos Fernandez Sanz (@carlos.fernandez on slack). Carlos wrote the original CEA-708 code.&lt;br /&gt;
Evgeny Shulgin (@izaron on slack). Evgeny is a 2016 Code-In Winner with CCExtractor, and worked a lot on CEA-708.\&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**How to get started**&lt;/strong&gt;&lt;br /&gt;
Best thing you can do is download a few samples (&lt;a href=&quot;public/general/tvsamples&quot;&gt;check our TV samples page&lt;/a&gt;) and try to solve some of the CEA-708 issues we have listed on GitHub.&lt;/p&gt;

&lt;p&gt;This is also the best way to get accepted into GSoC.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Complete 708 support</summary></entry><entry><title type="html">Public:gsoc:dtmb</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-dtmb.html" rel="alternate" type="text/html" title="Public:gsoc:dtmb" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:dtmb</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-dtmb.html">&lt;p&gt;&lt;strong&gt;Add support for DTMB countries&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DTMB is the Chinese TV standard, adopted by other countries such as Cuba. We still don’t know much about it. Due to this, your proposal must include:&lt;/p&gt;

&lt;p&gt;a) A link to the relevant standard documents. We don’t know if they exist in English. If they don’t but you speak the language they are in, that’s fine. If you locate the documents but they require payment (as is often the case for technical specifications) send us a link to buy and we’ll allocate organization funds to purchase them.&lt;br /&gt;
b) Some TV samples. Or, if you cannot get them directly, an explanation of how you will get them, for example by purchasing a capture card that is known to be compatible (send us an exact link), plugging it to an antenna or dish, etc, that you have access to (detail), etc.\&lt;/p&gt;

&lt;p&gt;In short, this is an “adventure” task. We’ll go all the way with the student that tries it, but we want to make sure the chances of success are reasonable.&lt;/p&gt;

&lt;p&gt;This is what we (think we) know so far:&lt;br /&gt;
DTMB regulates the physical transmission standard (signals, frequencies, etc). It seems to be available (for purchase) &lt;a href=&quot;http://www.chinesestandard.net/default.aspx?PDF-English-ID=GB%2020600-2006&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Cuba follows it:&lt;br /&gt;
http://www.globaltimes.cn/content/955479.shtml&lt;br /&gt;
http://advanced-television.com/2013/03/22/cuba-adopts-chinese-tv-standard/\&lt;/p&gt;

&lt;p&gt;The reason Cuba is interesting is that their subtitles will have Latin characters, which will make life a lot easier for most team members. Also, the Cuban government has a &lt;a href=&quot;http://www.lacetel.cu/television-digital/normas-de-television-digital.html&quot;&gt;good website&lt;/a&gt; about their TV regulations.&lt;/p&gt;

&lt;p&gt;Apparently the subtitles themselves follow the European DVB standard. We can see that &lt;a href=&quot;http://www.ofca.gov.hk/filemanager/ofca/common/Industry/broadcasting/standards/lists/hkca1108.pdf&quot;&gt;in this document&lt;/a&gt; from the Hong Kong regulatory body which says:&lt;/p&gt;

&lt;p&gt;Subtitles: Receivers shall include provisions to decode and display subtitles conforming to ETSI EN 300 743.&lt;/p&gt;

&lt;p&gt;The Cuban government &lt;a href=&quot;http://www.lacetel.cu/20160414_Verification_Test_Procedure_Res47.pdf&quot;&gt;says the same thing&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;That document (in English) says:
The Brand and Model TV Set is intended for the reception of DTMB Digital Terrestrial Television in 6MHz bandwidth, according to the specifications GB 20600-2006.\&lt;/p&gt;

&lt;p&gt;&lt;em&gt;and&lt;/em&gt;&lt;br /&gt;
DVB subtitles (ETSI EN 300 743) – The DUT must support DVB subtitles (ETSI EN 300 743).\&lt;/p&gt;

&lt;p&gt;Important: Since Chinese is by far the most extended language among DTMB countries, its support is essential. We have some preliminary support for it, but whatever is missing you will need to add. This applies in particular to the .srt writer. Since .srt is text based, you need to OCR the bitmaps. This is already done but almost untested for Chinese. Don’t assume it’s going to work. Probably not. Give yourself time in your proposal for this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**Related GitHub Issues**&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/918&quot;&gt;Extract subtitles in a Chinese newscast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Add support for DTMB countries</summary></entry><entry><title type="html">FFmpeg + Rust: Code builder</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-ffmpeg-rust.html" rel="alternate" type="text/html" title="FFmpeg + Rust: Code builder" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:ffmpeg-rust</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-ffmpeg-rust.html">&lt;p&gt;&lt;strong&gt;Why is this a CCExtractor project and not an FFmpeg project?&lt;/strong&gt;\ 
Because the FFmpeg team doesn’t need it :-) We do.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;br /&gt;
FFmpeg is, of course, everybody’s go-to tool when it comes to video manipulation: Resize, apply filters, convert to a different encoding or container, etc, it does it all. They even participate in GSoC every year!&lt;/p&gt;

&lt;p&gt;If you read their documentation, you will see that FFmpeg, the command-line tool, is mostly a “shell” that actually builds a graph that then runs in their libraries.&lt;/p&gt;

&lt;p&gt;For developers that need to use FFmpeg to do “something” specific with video, the usual way to do it it just by executing FFmpeg with the right parameters (using spawn, exec, or whatever it’s called in their language of choice), wait for it to finish, and then do something with the result.&lt;/p&gt;

&lt;p&gt;Often that’s good enough, but many times it’s not: You can’t easily get progress, you absolutely can’t do anything in the middle of the process and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your job&lt;/strong&gt;&lt;br /&gt;
Your job here is to build a “source code generator” that given a FFmpeg command line is able to write the source code of a program, preferably in Rust, that executes the graph using FFmpeg’s libraries - but this is not about spawning FFmpeg! For example, given a command line like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -i input.mkv -vf scale=320:240 output.mp4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can see that it’s going to read the file “input.mkv”, resize it to 320x240, and write it as output.mp4, so there’s a resize filter there and also a container conversion.&lt;/p&gt;

&lt;p&gt;What we want to get is a program that does that for exactly those files and those tasks, and it needs to use FFmpeg’s low level libraries so it’s possible to add code into the program that does whatever the developer needs to do: For example, they might want to modify each frame to add something that is not supported by an FFmpeg filter - may be something that needs to be fetched for an external source.&lt;/p&gt;

&lt;p&gt;Your output program needs to be compilable (of course) and do exactly the same thing as FFmpeg would do if called with the specified parameters.&lt;/p&gt;

&lt;p&gt;Of course, you are expected to dig into how FFmpeg does it and build from there.&lt;/p&gt;

&lt;p&gt;We prefer Rust but C would also be OK. However, if you already know C or C++ learning Rust is not too hard and it’s totally worth it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Why is this a CCExtractor project and not an FFmpeg project?\ Because the FFmpeg team doesn’t need it :-) We do.</summary></entry><entry><title type="html">rutorrent mobile interface</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-flutterrutorrent.html" rel="alternate" type="text/html" title="rutorrent mobile interface" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:flutterrutorrent</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-flutterrutorrent.html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;br /&gt;
rutorrent is the most popular web interface for rtorrent, which is possibly the most used BitTorrent client in linux. It is mostly a web application, but it has its own backend that connects to rtorrent. You could connect to rtorrent directly as well, but by doing that you would be missing lots of features that come with rutorrent, for example RSS support.&lt;/p&gt;

&lt;p&gt;Yes, there are two things with almost the same name. To summarize:&lt;/p&gt;

&lt;p&gt;rtorrent =&amp;gt; The BitTorrent client, a console-based tool that also has an API to interact with it.&lt;br /&gt;
rutorrent =&amp;gt; A web interface for rtorrent that uses that API. It also does other things, for example, it can download torrents from an RSS feed. You configure RSS feeds in rutorrent’s web interface, but there’s also a backend service (written in PHP) that is part of rutorrent to do the actual download.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your job&lt;/strong&gt;&lt;br /&gt;
The job is to write a Flutter based web interface that uses rutorrent’s backend service to provide a native interface.&lt;/p&gt;

&lt;p&gt;The basic things (for example, torrent listing) are easy to do, but rutorrent is extensible (it has good plugin support) and your tool needs to support that, too.&lt;/p&gt;

&lt;p&gt;The job is to write a native application that feels written for mobile. It’s not about cloning rutorrent’s interface. So yes there needs to be a torrent list but the columns may be different (definitely less), colors, sorting, how you interact with the tool and so on.&lt;/p&gt;

&lt;p&gt;rtorrent, by the way, runs in a server, and rutorrent is the web interface that lets you interact with rtorrent. We don’t want to add BitTorrent capability to mobile or anything like that. This is a 100% frontend job, using pre-existing work in rutorrent to control rtorrent from the phone.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;br /&gt;
In order to understand what to do you need to actually install rtorrent and rutorrent and play with them.\&lt;/p&gt;

&lt;p&gt;You don’t need to have previous experience (really, not important for this - it’s all about Flutter), but you won’t be able to come up with a good proposal if you don’t know how things work.&lt;/p&gt;

&lt;p&gt;Also, if you are unable to run rtorrent and rutorrent on your system, please use &lt;a href=&quot;https://hub.docker.com/r/crazymax/rtorrent-rutorrent&quot;&gt;this docker&lt;/a&gt; image.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction rutorrent is the most popular web interface for rtorrent, which is possibly the most used BitTorrent client in linux. It is mostly a web application, but it has its own backend that connects to rtorrent. You could connect to rtorrent directly as well, but by doing that you would be missing lots of features that come with rutorrent, for example RSS support.</summary></entry><entry><title type="html">Add Japanese support</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-japanese.html" rel="alternate" type="text/html" title="Add Japanese support" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:japanese</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-japanese.html">&lt;p&gt;Watch this video.&lt;/p&gt;

&lt;div class=&quot;video&quot;&gt;
    &lt;figure&gt;
        &lt;iframe width=&quot;640&quot; height=&quot;480&quot; src=&quot;//www.youtube.com/embed/7QhwgrOrnyE&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
    &lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;And then come with a plan :-)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;
Take a look at &lt;a href=&quot;/ccextractor-wiki-test/2020/03/05/public-gsoc-takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Watch this video.</summary></entry><entry><title type="html">JokerTV integration</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-jokertv.html" rel="alternate" type="text/html" title="JokerTV integration" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:jokertv</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-jokertv.html">&lt;p&gt;As you may know, our reference TV tuner has been for a long time the amazing HDHomeRun from Silicon Dust. They (all models) are rock-solid and they are really easy to integrate with. However, they don’t support DTMB (the Chinese standard).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tv.jokersys.com/&quot;&gt;This&lt;/a&gt; small thing is JokerTV (stand-alone version).&lt;/p&gt;

&lt;p&gt;You can see in the &lt;a href=&quot;https://tv.jokersys.com/tech-specs/&quot;&gt;tech specs&lt;/a&gt; that everything we care about is supported, and that the list of chipsets is published, and that &lt;a href=&quot;https://tv.jokersys.com/downloads/&quot;&gt;source code&lt;/a&gt; for everything, including firmware, is available.&lt;/p&gt;

&lt;p&gt;We are quite excited about the openness and potential of JokerTV and want to be the first to integrate with it. What should be the result of this integration?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CCExtractor would be able to communicate directly with JokerTV - getting the streams directly from it, as we do with the HDHomeRun.\&lt;/li&gt;
  &lt;li&gt;You don’t need to decode DTMB (that’s a different GSoC project, possibly a summer worth of work) but your integration needs to be as region agnostic as possible. If JokerTV works everywhere, then so must JokerTV+CCExtractor.\&lt;/li&gt;
  &lt;li&gt;It’s likely that JokerTV included support tools are not up to par with HDHomeRun’s yet. If this is the case (your proposal should show that you’ve done your homework and can tell us) reserve some time to work on this.\&lt;/li&gt;
  &lt;li&gt;Another two major programs that could use JokerTV integration are FFmpeg and Kodi (for their live TV and DVR functionality). We love cross project ideas, including of course sending patches to their maintainers. If you think you would have time for this, give it some consideration.\&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;About getting a JokerTV - we will buy one for the student that takes on this task. We will also have a few more distributed in different regions around the world so remote testing is possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**Related GitHub Issues**&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/CCExtractor/ccextractor/issues/918&quot;&gt;Extract subtitles in a Chinese newscast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**Mentor**&lt;/strong&gt;&lt;br /&gt;
Abylay Ospan, the genius behind JokerTV himself.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">As you may know, our reference TV tuner has been for a long time the amazing HDHomeRun from Silicon Dust. They (all models) are rock-solid and they are really easy to integrate with. However, they don’t support DTMB (the Chinese standard).</summary></entry><entry><title type="html">Public:gsoc:linuxtuning</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-linuxtuning.html" rel="alternate" type="text/html" title="Public:gsoc:linuxtuning" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:linuxtuning</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-linuxtuning.html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;br /&gt;
The linux kernel has hundreds of tunable settings. Some can be modified on the fly with sysctl; others require reboots, loading modules and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your job&lt;/strong&gt;&lt;br /&gt;
Your job is to come up with a self-tuning system that does all the analysis it needs and finds the optimum settings to maximize throughput and/or latency for well defined workloads. One of the must be BitTorrent, since that one uses a lot of traffic and it can just be tested with real data instead of synthetic tests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction The linux kernel has hundreds of tunable settings. Some can be modified on the fly with sysctl; others require reboots, loading modules and so on.</summary></entry><entry><title type="html">Add support for Live TV over the internet (such as YouTube TV)</title><link href="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-livetvooverinternet.html" rel="alternate" type="text/html" title="Add support for Live TV over the internet (such as YouTube TV)" /><published>2020-03-05T00:00:00-06:00</published><updated>2020-03-05T00:00:00-06:00</updated><id>https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public:gsoc:livetvooverinternet</id><content type="html" xml:base="https://dumbmachine.github.io/ccextractor-wiki-test/2020/03/05/public-gsoc-livetvooverinternet.html">&lt;p&gt;A number of platforms are appearing these days to distribute local TV content over the internet. For example, YouTube now has a live TV. Hulu does, too.&lt;/p&gt;

&lt;p&gt;It’s still early days for these platforms - they’re trying to grab the business from the cable-cutters, while (possibly, for now) providing the same functionality, which is a live TV with DVR. It’s possible of course that they will offer lots of new features and they manage to replace over the air broadcasts, cable…&lt;/p&gt;

&lt;p&gt;Anyway, we don’t know how they are implementing subtitles, and the task this summer is to&lt;/p&gt;

&lt;p&gt;a) Do the research&lt;br /&gt;
b) Write code that is able to create transcripts in the usual formats such as .srt&lt;/p&gt;

&lt;p&gt;This code might be integrated with the current CCExtractor core or it could be a new tool. What’s best depends mostly on how the subtitles are distributed. If they are embedded in transport streams then integrating with CCExtractor would be the natural option. It’s part of the job to figure this out.&lt;/p&gt;

&lt;p&gt;We’re going to target the two major platforms that have a live TV over the internet: YouTube and Hulu.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We will pay for the subscriptions for both services during the coding period, and if you are currently outside the geographical areas in which these services are available, we’ll provide a VPN as well&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Features that we expect:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The system must be completely scriptable. For example, a solution that requires human intervention to start a capture session, or a browser open on a desktop is not going to work. Suppose we want the system running 24x7 on a Linux server, which might not even have a monitor.\&lt;/li&gt;
  &lt;li&gt;Youtube TV supports a maximum of 6 simultaneous streams per subscription. We don’t know about Hulu, but the point is that your solution must be able to maximize what we get from the subscription - if the service allows 6 streams, your solution must too.\&lt;/li&gt;
  &lt;li&gt;Allow several subscriptions to be used as well, for example, if we want 12 streams, then 6x2 should work.\&lt;/li&gt;
  &lt;li&gt;It goes without saying, login information should be configurable and you must be careful not to push any real information to GitHub.\&lt;/li&gt;
  &lt;li&gt;Documentation must be good - we want other projects to build on this one instead of having to figure out everything from scratch.\&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Qualification tasks&lt;/strong&gt;&lt;br /&gt;
Take a look at &lt;a href=&quot;https://ccextractor.org/public/gsoc/takehome&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">A number of platforms are appearing these days to distribute local TV content over the internet. For example, YouTube now has a live TV. Hulu does, too.</summary></entry></feed>